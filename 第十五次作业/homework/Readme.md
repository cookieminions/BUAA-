# Readme

tags： 面向对象课程文档 Java

---

[TOC]

###程序运行所需环境和运行指令规范

    Java version "1.8.0_101"
    Java(TM) SE Runtime Environment (build 1.8.0_101-b13)
    Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)
    Eclipse IDE for Java Developers	Version: Neon Release (4.6.0)
    程序输入由Eclipse控制台输入

###程序输入说明，包括标准输入格式、输入限制和遇见输入错误时的响应信息

####**标准输入格式**
1. 乘客请求格式
* 标准请求格式为 `[CR,(x1,y1),(x2,y2)]` 如 `[CR,(0,5),(10,0)]`
* 请求的发出点和目的地坐标的 x 与 y 取值范围都是 [0,79]，也就是说最左上角的点为 (0,0) 最右下角的点为 (79,79)

2. 乘客请求输入方式
* 控制台输入
* 在测试的demo线程中使用 reqList 的 submitReq(String str) 方法提交请求，其中请求格式仍为标准格式

####**输入限制**
* 请求需要符合标准请求格式
* 请求中的起点和终点坐标的 x 和 y 需要在 [0,79] 内取值
* 控制台输入一个请求后回车输入下一个，不允许一次复制粘贴多行请求

####**遇见输入错误时的响应信息**
* 对于不符合标准请求格式的请求，程序会在控制台输出 `INVALID REQ` 并忽略请求
* 对于提交多条格式与内容完全一样的请求，如果请求发出的时间也完全相同，将被认为是相同请求，程序会在控制台输出 `SAME REQ CR-(x1 y1)To(x2 y2)-reqT` 其中 reqT 为请求发出时间，相同请求会被忽略

###程序计算结果的输出规格和一些说明

####**地图文件读取**
* 程序会从 D:\city_map.txt 中读取地图
* 地图不允许有连通地图外的点
* 地图必须是连通图，连通性由测试者保证
* 文件中存储的内容要求与指导书上的说明相同，允许在数字之间插入空格或制表符
* 对于不满足条件的地图文件，程序会输出 `cityMap error` 并结束运行

####**结果输出**
* 对于每一条有效的乘客请求，结果会写入到项目目录下的以 CR-(x1 y1)To(x2 y2)-reqT.txt 命名的文件中
* 输出结果文件中的第一行是请求发出时，处于以请求src为中心的4×4区域中的所有出租车状态、信用信息（当前请求抢单之前的信用信息）；第二行是在抢单时间窗内所有抢单的出租车；第三行是系统选择响应相应请求的出租车；第四行是出租车响应相应请求过程中的实际行驶路径
* 对于第四行行驶路径的说明：首先是 MoveToC 部分：包括从出租车将到达的下一个点到到达乘客位置前的一个点经过的路径；然后是 MoveToD 部分：包括从乘客位置到乘客目的地之间经过的路径；输出的点的坐标的x与y的取值范围都是[0,79]
* 如果有效的乘客请求没有符合要求的出租车响应，程序会在控制台输出 `No Taxi ReSponse at CR-(x1 y1)To(x2 y2)-reqT` 但是依然会有结果输出到文件中，第三行会输出 `No Taxi Response` 其他行对应为空
* 出租车目前不具备捎带功能
* 如果原来规划的路径上的道路被关闭，出租车会改变道路，从道路关闭处重新规划最短路径

####**关于最短路径**
* 亲测 gui 的最短路径算法在原来路径出现断路后结果不会改变（也就是说结果是错的），因为 gui 在断路时只是在画布上擦掉了连线，而 gui 的算法在计算时并没有断路，所以不能全部依靠 gui 关于最短路径长度的输出，需要依靠 gui 可见的实际情况计算

####**状态说明**
* 请求发出后寻找的以请求src为中心的4×4区域是包括4条边的
* 提交请求以及输出结果时的坐标位置中 x 与 y 的取值范围都是 [0,79]
* 出租车的编号是 0-99
* 出租车的状态代号为：等待状态 waiting；停止状态：stop；接单状态：moving；服务状态：serving

####**关于时间的说明**
关于时间的说明：为了便于观察，程序选择程序开始运行的系统时间为 startTime 即出租车系统时间开始点，之后所有的时间都是取系统时间然后经过计算得到的相对的出租车系统时间；出租车系统的基本时间单位为 100ms 所以输出的所有时间的个位的基本位是 100ms，举例来说，时间为 `31.0` 说明该时间距离程序开始运行 3100ms

####**gui的说明**
* gui可能出现的画图错误或者抽风可能造成程序中断影响到文件写入...
* 新版出租车一直是粉色的，会因为红绿灯的暂停抖动...

####**关于红绿灯的说明**
* 程序会从 D:\lights_map.txt 中读取红绿灯信息
* 红绿灯位置的正确性由测试者保证，原则上说红绿灯需要在分叉路口才能出现
* 增删路径可能影响红绿灯的正确性，但是程序依然认为红绿灯在运行
* 程序的红绿灯初始状态是随机的，但是变化间隔时间是相同且固定的，变化间隔时间是在程序运行开始时随机确定的

####**关于可追踪出租车的说明**
* 可追踪出租车在本程序中是 newtaxi 类，继承了 taxi 类，newtaxi 类提供了 iterator 方法返回一个迭代器，用来查询该出租车的服务记录
* 对可追踪出租车满足 LSP 原则的论证：newtaxi 类重写了 taxi 类的 desMove2C、desMove2D、randomMove、findroute、iterator 方法，使得可追踪出租车可以行走在断开的边上，这些方法的重写并没有增加前置要求REQUIRES，后置的EFFECTS也是相同的，在任何出现基类 taxi 也就是普通出租车的地方都可以用 newtaxi 代替
* 可追踪出租车的行驶：可追踪出租车可以行驶在关闭的边上，但是关闭的边指的是地图上原本存在之后被关上的边，对于最开始地图上就不存在的边是不能行驶的

####**关于迭代器的说明**
* 本程序实现的迭代器接口是课件中的双向迭代器 TwoWayIterator 接口，实现的方法有 hasNext、next、hasPrevious、previous
* 针对某一辆可追踪出租车，调用出租车的 iterator 方法返回迭代器，`TwoWayIterator itr = taxis[i].iterator`
* 在获得迭代器后，调用 `itr.hasNext()` 或者 `itr.hasPrevious()` 可以得到是否存在下一个或上一个元素；调用 `itr.next()` 或者 `itr.previous()` 可以获取下一个或上一个元素；如果不存在下一个或者上一个元素，调用会返回 null 并输出错误信息
* 迭代器每次返回的信息是一个出租车执行一个请求后所有的信息，包括请求发出的时间，出发点和目的地，请求响应时出租车位置以及出租车运动路径
* 迭代器通过 next 和 previous 都可以遍历整个容器
* 迭代器的使用规范在 demothread 中已经给出，测试者可以自己查看

####**关于init_taxi的说明**
init_taxi 方法中有自己写的部分不过被注释了

###提供测试的接口说明
* 程序中提供了一个 demothread，里面包括了对于测试接口的使用的示例；需要注意的是，如果测试者自己构建线程，需要类似 demothread 传入 main 函数中的 reqlist 和 taxi\_Sys 和 taxis 还有 newMap 对象
* 查询指定出租车的状态：Taxi\_Sys 类的 getTaxiInfor(int i) 返回编号为 i 的出租车的状态，位置（如果出租车在两个点中间 位置是上一个点）和 执行查询时的时间组成的字符串
* 根据状态返回处于状态的出租车：Taxi\_Sys 类的 getTaxisAtStatus(String status) 返回处于 status 状态的所有出租车编号组成的字符串
* 通过线程直接提交请求：ReqList类的 submitReq(String str) 方法
* 道路关闭：CityMap类的 setClose(int i1,int j1,int i2,int j2) 方法，表示的是需要关闭的是 (i1, j2) 和 (i2, j2) 之间的道路，需要注意的是：传入的点必须是地图内的，两个点需要不同且相邻，不能关闭已经关闭的道路，有车行驶的道路也不能关闭，如果不满足上述条件，则不会执行关闭道路；此外地图的连通性需要测试者保证
* 道路打开：CityMap类的 setOpen(int i1,int j1,int i2,int j2) 方法，表示的是需要打开的是 (i1, j2) 和 (i2, j2) 之间的道路，需要注意的是：传入的点必须是地图内的，两个点需要不同且相邻，不能打开地图上原本不存在的边，不能打开已经打开的道路，如果不满足上述条件，则不会执行打开道路

###上次作业的bug
* 第九次作业没有bug
* 第十次作业存在一个bug，就是红绿灯文件如果不为全1，那么会出现出租车全部等待的局面...因为自己测试的时候使用的是全1的文件，没有发现，这个bug只需加一行return就可解决，然而造成现在无效然后在申诉的局面（囧），因此在测试者拿到测试文件时可能无效已经变成了有效然后没有bug，也有可能结果还没有返回会出现12个公测集；不过写readme时还没有返回结果...（大写囧）



